<!DOCTYPE html>
<html>
    <head>
        <title>KnotMarker</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0-beta1/jquery.min.js"></script>
        <!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

    </head>
    <script>
        function KnotMarker() {
            function url(s) {
                var l = window.location;
                return ((l.protocol === "https:") ? "wss://" : "ws://") + l.host + l.pathname + s;
            }
            var webSocket = new WebSocket(url("ws"));

            var progress = document.getElementById("progress");

            webSocket.binaryType = "arraybuffer";
            webSocket.onopen = function (event) {
                requestImage();
            };

            var newImageLoaded = false,
                currentDefect = false,
                imageProcessing = false;

            var counterSpan = document.getElementById("counter");

            function onMessage(data) {
                console.log(data);
                switch (data.type) {
                    case "defect":
                        defects.push(data.rect);
                        if (newImageLoaded) {
                            nextDefect();
                        }
                        break;
                    case "imagesAvailable":
                        counterSpan.innerHTML = data.value;
                    case "imageProcessed":
                        progress.style.display = "none";
                        imageProcessing = false;
                        console.log(defects);
                        drawDefects();
                }
            }

            function nextDefect() {
                console.log("nextDefect");
                newImageLoaded = false;
                currentDefect = defects.pop();
                drawDefects();
            }

            function drawDefects() {
                console.log("drawDefects");
                if (tempImageData)
                    ctx.putImageData(tempImageData, 0, 0);
                for (var i = 0; i < defects.length; ++i) {
                    drawDefect(defects[i], "green");
                }
                drawDefect(currentDefect);
            }

            function onImage(data) {
                defects = [];
                newImageLoaded = true;
                imageProcessing = true;
                var blob = new Blob([event.data], {type: "image/png"});
                var image = new Image();
                image.onload = function () {
                    drawImage(this);
                    URL.revokeObjectURL(this.src);
                }
                progress.style.display = "block";
                image.src = URL.createObjectURL(blob);
            }

            webSocket.onmessage = function (event) {
                switch (typeof event.data) {
                    case "string":
                        var data = JSON.parse(event.data);
                        onMessage(data);
                        break;
                    case "object":
                        onImage(event.data);
                        break;
                }
            };

            var defects = [];

            var canvas = document.getElementById("surface"),
                canvasWidth = canvas.width,
                canvasHeight = canvas.height,
                ctx = canvas.getContext("2d"),
                tempImageData = false;

            function drawImage(image) {
                webSocket.send(JSON.stringify({
                    type: "imageLoaded"
                }));
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.drawImage(image, 0, 0);
                tempImageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            }

            function drawDefect(rect, color) {
                ctx.strokeStyle = color || "red";
                ctx.strokeRect(rect[0], rect[1], rect[2], rect[3]);
            }

            function markDefect(defect_type) {
                if (defect_type) {
                    webSocket.send(JSON.stringify({
                        defect: currentDefect,
                        type: defect_type
                    }));
                    if (defects.length > 0) {
                        nextDefect();
                    } else {
                        requestImage();
                    }
                } else {
                    requestImage();
                }
            }

            function requestImage() {
                webSocket.send(JSON.stringify({
                    "type": "requestImage"
                }));
            }

            document.addEventListener("keyup", function(evt) {
                if (imageProcessing)
                    return;
                var defect_types = [
                        {% for defect_type,_,__ in defects %}
                            "{{ defect_type }}",
                        {% endfor %},
                        false
                ];
                var keycodes = [
                    {% for _,key,__ in defects %}
                            "{{ key }}".charCodeAt(0) - 32,
                    {% endfor %},
                    "s".charCodeAt(0) - 32
                ];
                ind = keycodes.indexOf(evt.keyCode);
                if (ind === -1)
                    return false;
                markDefect(defect_types[ind] || false);
                return true;
            }, false);
        };

    </script>
    <style>
        div.thumbnail.defect {
/*            width: 600px !important;*/
            /*height: 200px !important;*/
            text-align:center; display:table-cell; vertical-align:middle;
        }

        div.thumbnail.defect img {
        }
    </style>
    <body onload="KnotMarker();">
        <div class="container">
            <h1>KnotMarker</h1>
            <div class="row">
                <canvas id="surface" width="800" height="300"></canvas>
            </div>
            <div class="row">
            <div id="progress" class="progress">
                <div class="progress-bar progress-bar-striped active" role="progressbar" aria-valuenow="45" aria-valuemin="0" aria-valuemax="100" style="width: 100%">
                    <span class="sr-only">100% Complete</span>
                </div>
            </div>
            </div>
            <div class="row">
                Осталось <span id="counter">{{ images_available }}</span> изображений.
                <table class="table table-condensed">
                    <thead>
                        <tr>
                            <th>Тип дефекта</th>
                            <th>Кнопка</th>
                            <th>Описание</th>
                        </tr>
                    </thead>
                    <tbody>
                    {% for defect_type, defect_key, defect_desc in defects %}
                        <tr>
                            <td>
                                {{ defect_type }}
                            </td>
                            <td>
                                {{ defect_key }}
                            </td>
                            <td>
                                {{ defect_desc }}
                            </td>
                        </tr>
                    {% endfor %}

                        <tr>
                            <td>
                            skip
                            </td>
                            <td>s</td>
                            <td>Пропустить изображение</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="row">
                <p>
                KnotMarker отображает случайное изображение доски из нашей библиотеки
                и предлагает пользователю определить класс, к которому относится
                выделененная область доски. Выбор класса производится только с клавиатуры,
                после выбора класса KnotMarker предлагает пользователю следующую область
                или переходит к новому изображению, если областей больше не осталось.
                </p>
                <p>
                Области, которые KnotMarker предлагает для классификации, выделяются
                полностью автоматическим алгоритмом.
                </p>
            </div>
        </div>
    </body>
</html>

